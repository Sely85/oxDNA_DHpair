//Lara Querciagrossa, May 2019
#include <stdio.h>
#include <cstdlib>
#include <memory>
#include <cassert>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <strstream>
#include <cmath>
#include "math.hpp"
#include "math-quat.hpp"

#define THIRD 0.333333333333333
#define ROOTTHREE 1.73205080756888       
#define PI 3.141592653589793238462643383279502884197
 
using namespace std;


double computeDH(double dist, double temp, double rhos, double qeff)
{
  double edh;

  //OXDNA2 notes from LAMMPS sources 12Dec18

  // Debye length and inverse Debye length  
  /*
    The numerical factor is the Debye length in s.u.
    lambda(T = 300 K = 0.1) =
    sqrt(eps_0 * eps_r * k_B * T/(2 * N_A * e^2 * 1000 mol/m^3))
          * 1/oxDNA_energy_unit
    (see B. Snodin et al., J. Chem. Phys. 142, 234901 (2015).)
  */

  double eps0 = 8.854187817e-12; // vacuum permittivity, F/m
  double epsr = 80; // relative permittivity of water
  double kB  = 1.3806485279e-23; //Boltzmann constant, J/K
  double tKox = 300.0/0.1; //K, 
  double NA = 6.02214085774e23; // / mol,  Avogadro constant
  double elq  = 1.6021766208e-19; // C, elementary charge
  double sigox = 8.518e-10; // m, oxDNA_length_unit
  double epsox = 4.142e-20; // J, oxDNA_energy_unit

  double numlambda = eps0*epsr*kB*tKox*0.001;
  double denlambda = 2.0*NA*elq*elq;
  double coefflambda = sqrt(numlambda/denlambda);
  double lambdaDH = coefflambda * sqrt(temp/rhos);
  lambdaDH = lambdaDH/sigox;

  double kappaDH = 1.0/lambdaDH;

  // prefactor in DH interaction containing qeff^2
  /*
      The numerical factor is
      qeff_dh_pf = e^2/(4 * pi * eps_0 * eps_r)
                    * 1/(oxDNA_energy_unit * oxDNA_length_unit)
      (see B. Snodin et al., J. Chem. Phys. 142, 234901 (2015).)
  */

  double qeffcon = elq*elq/(4.0*PI*eps0*epsr);
  qeffcon = qeffcon/(sigox*epsox);

  edh = qeff*qeff*qeffcon * (1.0/dist) * exp(-dist*kappaDH);

  return edh;
}


int main(int argc, char *argv[])
{

  if ( argc == 2 && ( string(argv[1]) == "--help" || string(argv[1]) == "-h" ) ) 
    {
      std::cout << " " << std::endl;
      std::cout << " Welcome to the oxDNA_DHpair code!" << std::endl;
      std::cout << " This code will compute the oxDNA2 Debye Huckel interaction for a " << std::endl;
      std::cout << " specific pair (id1 & id2) in a dump file (generated by LAMMPS) " << std::endl;
      std::cout << " " << std::endl;
      std::cout << " To determine this electrostatic energy, temperature (in oxDNA units, 0.1 = 300K)," << std:: endl;
      std::cout << " salt concentration (mole per liter) and effective charge (elementary charges) should be written." << std::endl;
      std::cout << " If the effective charge is not chosen, it will be assumed to be qeff = 0.815, as described in oxDNA2 model. " << std::endl;
      std::cout << " " << std::endl;
      std::cout << " " << std::endl;
      std::cout << " ./oxDNA_DHpair <oxDNAdump> <id1> <id2> <temp> <rhos> <qeff>" << std::endl;
      std::cout << " " << std::endl;
    }
  else if ( argc < 6 || argc > 7 )
    {
      std::cout << "[ERROR] Wrong number of input parameters: ./oxDNA_DHpair <oxDNAdump>  <id1> <id2> <temp> <rhos> <qeff>" << std::endl;
      return 0;
    }
  else 
    {

      //Reading configuration name
      ifstream conf ( argv[1] );
      if ( !conf.is_open() )
	{
	  cout<<"ERROR: Could not open dump file\n";
	  return 0;
	}

      std::cout << "Your configuration file is: " << argv[1] << std::endl;
      std::cout << " " << std::endl;


      //Reading ids of beads
      int id1 = atoi(argv[2]);
      int id2 = atoi(argv[3]);


      //Reading systems setting
      double temp = atof(argv[4]); //temperature (oxDNA units, 0.1 = 300K)
      double rhos = atof(argv[5]); //salt concentration (mole per liter)
      double qeff; //effective charge (elementary charges)
      if ( argc == 7 )
	qeff = atof(argv[6]);
      else 
	qeff = 0.815;

      //Printing system sump
      std::cout << "Computing electrostatic energy between beads " << id1 << " and " << id2 << std::endl;
      std::cout << "at temperature " << temp << ", at salt concentration " << rhos << " (M) " << std::endl;
      std::cout << "and with effective charge of " << qeff << std::endl;
      std::cout << " " << std::endl;


      /** Read configuration(s) **/

      //Count lines in files
      string line; 
      int totlines = 0;
      int totsteps = 0;
      string itemtimestep = "ITEM: TIMESTEP";
      while ( getline(conf,line) )
	{
	  string first = line;
	  if ( first.compare(itemtimestep) == 0 )
	    {
	      totsteps++;
	    }
	  totlines++;
	}
      //Print number of configurations in the input dump file
      std::cout << "In your configuration file, there are " << totsteps << " steps." << std::endl;
      std::cout << " " << std::endl;

      //Configuration file has been read till the end: this position is cleared and than we set the new position to be read next at the beginning of the file
      conf.clear();
      conf.seekg(0, std::ios::beg);

      //Empty string to avoid storage of unnecessary information
      string null;

      //Write an output file with distance and energy
      ofstream fileout("DHenergy.txt", ios::out);
      fileout << "#[1]timestep [2]distance [3]DH-energy " << std::endl;

      //File will be read one line at a time to save memory
      //Reading one configuration at a time
      for (int i=0; i<totsteps; i++)
	{
	  //std::cout << "Analyzing step " << i+1 << "/" << totsteps << std::endl;

	  int timestep, atoms;
	  double xlo, xhi, ylo, yhi, zlo, zhi;

	  //Reading dump
	  conf >> null >> null;
	  conf >> timestep;
	  conf >> null >> null >>  null >> null;
	  conf >> atoms;
	  conf >> null >> null >>  null >> null >> null >> null;
	  conf >> xlo >> xhi;
	  conf >> ylo >> yhi;
	  conf >> zlo >> zhi;

	  //Reading header
	  conf >> null >> null >> null >> null >> null >> null >> null >> null >> null >> null >> null >> null >> null >> null >> null >> null >> null >> null >> null >> null >> null;

	  double* bb1 = new double[3];
	  double* bb2 = new double[3];

	  int cnt = 1;
	  //Reading atoms in each configuration
	  for (int b=0; b<atoms; b++)
	    {
	      int mol, id, type; //MoleculeID, AtomID, AtomType
	      double rx, ry, rz; //Position of com
	      double qw, qx, qy, qz; //Orientation
	      double sx, sy, sz; //Shape
	      double vx, vy, vz; //Velocities 
	      double wx, wy, wz; //Angular velocities

	      //Storing one bead info
	      conf >> id >> type >> rx >> ry >> rz >> qw >> qx >> qy >> qz >> sx >> sy >> sz >> vx >> vy >> vz >> wx >> wy >> wz >> mol;

	      //Finding bead corresponding to chosen id1
	      if (id == id1)
		{
		  double quat[4] = {qw, qx, qy, qz};
		  double** mat = QuaternionToMatrix(quat);

		  double bx, by, bz; //Backbone-baseversor
		  double nx, ny, nz; //Normalversor 

		  bx = mat[0][0];
		  by = mat[0][1];
		  bz = mat[0][2];
		  nx = mat[2][0];
		  ny = mat[2][1];
		  nz = mat[2][2];

		  //Backbone site: (center) - 0.40 * (axis_vector)
		  bb1[0] = rx-0.4*bx;
		  bb1[1] = ry-0.4*by;
		  bb1[2] = rz-0.4*bz;
		}

	      //Finding bead corresponding to chosen id2
	      if (id == id2)
		{
		  double quat[4] = {qw, qx, qy, qz};
		  double** mat = QuaternionToMatrix(quat);

		  double bx, by, bz; //Backbone-baseversor
		  double nx, ny, nz; //Normalversor 

		  bx = mat[0][0];
		  by = mat[0][1];
		  bz = mat[0][2];
		  nx = mat[2][0];
		  ny = mat[2][1];
		  nz = mat[2][2];

		  //Backbone site: (center) - 0.40 * (axis_vector)
		  bb2[0] = rx-0.4*bx;
		  bb2[1] = ry-0.4*by;
		  bb2[2] = rz-0.4*bz;
		}

	    }

	  //Compute distance between backbone sites of two chosen beads
	  double* distv = distance(bb1, bb2);
	  double dist = norm(distv);

	  //Compute Debye-Huckel energy
	  double edh = computeDH(dist, temp, rhos, qeff);

	  //Print distance & electrostatic energy 
	  //std::cout << "Timestep: " << timestep << " Distance: " << dist << " Energy: " << edh << std::endl;
	  fileout << timestep << " " << dist << " " << edh << std::endl;

	}
      
    }

  //End
  std::cout << "A file called DHenergy.txt has been written. " << std::endl;
  std::cout << " " << std::endl;

}
